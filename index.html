<head>


  <style>
    body {
      font-family: "avenir next", Arial, sans-serif;
      margin: 0;
      background: lightgray;
    }

    .viz {
      top: 0;
      background: darkgray;
    }

    table {
      /*position: absolute;*/
      /*top: 10%;*/
      /*right: 35%;*/
    }

    td {
      min-width: 120px;
      border: black;
      border-style: ridge;
      padding: 5;
      border-width: thin;
    }

    td.data {
      min-width: 220px;
    }

    h1 {
      text-align: center;
      padding-top: 1%;
    }

    svg {
      margin: auto;
      display: block;
    }

    .bubble {
      cursor: pointer;
    }

    .page {
      overflow-y: hidden;
      /*max-height: 500px; !* approximate max height *!*/

      transition-property: all;
      transition-duration: .5s;
      transition-timing-function: cubic-bezier(0, 1, 0.5, 1);
    }

    .page.closed {
      max-height: 0;
    }
  </style>
</head>
<body onload="loadConstructorsPage()">
<h1 style="">Formula 1 World Championships (1950 - 2020)</h1>
<div id="page-1" class="page closed">
  <div id='vis-all-constructors' class="viz">
    <div id="bubble-detail">
      <table>
        <tr>
          <td>Constructor</td>
          <td id="td-constructor-name" class="data"></td>
        </tr>
        <tr>
          <td>Nationality</td>
          <td id="td-constructor-nationality" class="data"></td>
        </tr>
        <tr>
          <td>Races</td>
          <td id="td-constructor-races" class="data"></td>
        </tr>
        <tr>
          <td>Wins</td>
          <td id="td-constructor-wins" class="data"></td>
        </tr>
      </table>
    </div>
  </div>
</div>
<div id="page-2" class="page closed">
  <div id='vis-constructor-drivers'></div>
</div>
<div id="page-3" class="page closed">
  <div id='vis-driver'></div>
</div>
</body>
<script src='https://d3js.org/d3.v5.min.js'></script>
<script>
  var defaultBubbleColor = "#0074D9";
  var constructor_standings, constructors, races, contructor_wins, results;
  var constructor_arr = [];
  var selectedConstructor = null;
  var selectedDriver = null;
  var drivers = null;

  async function loadDriversPage() {
    document.getElementById('page-2').classList.toggle('closed');
    if (!drivers) {
      drivers = await d3.csv("https://raw.githubusercontent.com/akshatvn/f1/main/data/drivers.csv");
      delete drivers.columns;
    }
    console.log("drivers", drivers);

    if (!results) {
      results = await d3.csv("https://raw.githubusercontent.com/akshatvn/f1/main/data/results.csv");
      delete results.columns;
    }
    console.log("results", results);
    

  }

  async function loadConstructorsPage() {

    constructor_standings = await d3.csv("https://raw.githubusercontent.com/akshatvn/f1/main/data/constructor_standings.csv");
    constructors = await d3.csv("https://raw.githubusercontent.com/akshatvn/f1/main/data/constructors.csv");
    races = await d3.csv("https://raw.githubusercontent.com/akshatvn/f1/main/data/races.csv");


    // console.log("constructors", constructors);

    delete constructor_standings.columns;
    delete constructors.columns;
    delete races.columns;


    contructor_wins = {};
    for (i = 0; i < constructor_standings.length; i++) {
      let record = constructor_standings[i];
      if (!contructor_wins[record.constructorId]) {
        let currentConstructor = constructors.find(c => c.constructorId == record.constructorId)
        contructor_wins[record.constructorId] = {
          id: record.constructorId,
          name: (currentConstructor).name,
          wins: 0,
          races: 0,
          nationality: currentConstructor.nationality,
          color: (currentConstructor).color,
          driver_ids: []
        }
      }
      if (record.position === "1") {
        contructor_wins[record.constructorId].wins += 1;
      }
      contructor_wins[record.constructorId].races += 1;
    }

    console.log("contructor_wins: ", contructor_wins);
    for (const constructorId in contructor_wins) {
      constructor_arr.push(contructor_wins[constructorId])
    }
    constructor_arr = constructor_arr.sort((a, b) => a.wins < b.wins ? 1 : -1)
    console.log("constructor_arr: ", constructor_arr);

    display(constructor_arr);
    document.getElementById('page-1').classList.toggle('closed');
  }

  function bubbleChart() {
    const width = window.innerWidth * 0.8;
    const height = window.innerHeight;


    // location to centre the bubbles
    const centre = {x: width / 2, y: height / 2};

    // strength to apply to the position forces
    const forceStrength = 0.02;

    // these will be set in createNodes and chart functions
    let svg = null;
    let bubbles = null;
    let labels = null;
    let nodes = [];

    // charge is dependent on size of the bubble, so bigger towards the middle
    function charge(d) {
      return Math.pow(d.radius, 2.0) * 0.05
    }

    // create a force simulation and add forces to it
    const simulation = d3.forceSimulation()
      .force('charge', d3.forceManyBody().strength(charge))
      // .force('center', d3.forceCenter(centre.x, centre.y))
      .force('x', d3.forceX().strength(forceStrength).x(centre.x))
      .force('y', d3.forceY().strength(forceStrength).y(centre.y))
      .force('collision', d3.forceCollide().radius(d => d.radius * 1.25));

    // force simulation starts up automatically, which we don't want as there aren't any nodes yet
    simulation.stop();

    // set up colour scale
    // const fillColour = d3.scaleOrdinal()
    //   .domain(["1", "2", "3", "5", "300"])
    //   .range(["#0074D9", "#7FDBFF", "#39CCCC", "#3D9970", "#AAAAAA"]);

    // data manipulation function takes raw data from csv and converts it into an array of node objects
    // each node will store data and visualisation values to draw a bubble
    // rawData is expected to be an array of data objects, read in d3.csv
    // function returns the new node array, with a node for each element in the rawData input
    function createNodes(rawData) {
      // use max size in the data as the max in the scale's domain
      // note we have to ensure that size is a number
      const maxSize = d3.max(rawData, d => 4 + (+d.wins) * 5);

      // size bubbles based on area
      const radiusScale = d3.scaleSqrt()
        .domain([0, maxSize])
        .range([0, height / 12])

      // use map() to convert raw data into node data
      const myNodes = rawData.map(d => ({
        ...d,
        radius: radiusScale(4 + (+d.wins) * 5),
        // size: +d.wins,
        x: (Math.random() - 0.5) * width,
        y: (Math.random() - 0.5) * height
      }));

      return myNodes;
    }

    // main entry point to bubble chart, returned by parent closure
    // prepares rawData for visualisation and adds an svg element to the provided selector and starts the visualisation process
    let chart = function chart(selector, rawData) {
      // convert raw data into nodes data
      nodes = createNodes(rawData);

      // create svg element inside provided selector
      svg = d3.select(selector)
        .append('svg')
        .attr('width', 0.9 * width)
        .attr('height', 0.9 * height)
        .attr('style', 'backgound: lightgray;');

      // bind nodes data to circle elements
      const elements = svg.selectAll('.bubble')
        .data(nodes, d => d.id)
        .enter()
        .append('g');

      bubbles = elements
        .append('circle')
        .classed('bubble', true)
        .attr('r', d => d.radius)
        .attr('constructor-id', d => d.id)
        .attr('fill', function (d) {
          if (d.color != "") {
            return d.color;
          }
          return defaultBubbleColor;
        })
        .on("mouseover", handleMouseOverConstructor)
        .on("mouseout", handleMouseOutConstructor)
        .on("click", handleMouseClickOnConstructor);

      // labels
      labels = elements
        .append('text')
        .attr('constructor-id', d => d.id)
        .classed('bubble-label', true)
        .attr('dy', '.3em')
        .attr('id', d => "bubble-label-" + d.id)
        .style('text-anchor', 'middle')
        .style('font-size', 12)
        .style('fill', d => invertColor(d.color))
        .text(d => d.wins > 45 ? d.name + ": " + d.wins : "")
        .on("mouseover", handleMouseOverText)
        .on("mouseout", handleMouseOutText);

      // set simulation's nodes to our newly created nodes array
      // simulation starts running automatically once nodes are set
      simulation.nodes(nodes)
        .on('tick', ticked)
        .restart();
    };

    // callback function called after every tick of the force simulation
    // here we do the actual repositioning of the circles based on current x and y value of their bound node data
    // x and y values are modified by the force simulation
    function ticked() {
      bubbles
        .attr('cx', d => d.x)
        .attr('cy', d => d.y);

      labels
        .attr('x', d => d.x)
        .attr('y', d => d.y);
    }

    // return chart function from closure
    return chart;
  }

  let myBubbleChart = bubbleChart();

  function display(data) {
    myBubbleChart('#vis-all-constructors', data);
  }

  function invertColor(hex) {
    if (hex.indexOf('#') === 0) {
      hex = hex.slice(1);
    }
    // convert 3-digit hex to 6-digits.
    if (hex.length === 3) {
      hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    }
    if (hex.length !== 6) {
      hex = defaultBubbleColor;
    }
    // invert color components
    var r = (255 - parseInt(hex.slice(0, 2), 16)).toString(16),
      g = (255 - parseInt(hex.slice(2, 4), 16)).toString(16),
      b = (255 - parseInt(hex.slice(4, 6), 16)).toString(16);
    // pad each with zeros and return
    return '#' + padZero(r) + padZero(g) + padZero(b);
  }

  function padZero(str, len) {
    len = len || 2;
    var zeros = new Array(len).join('0');
    return (zeros + str).slice(-len);
  }

  // Create Event Handlers for mouse
  function handleMouseOverConstructor(d, i) {  // Add interactivity

    // Use D3 to select element, change color and size
    selectedConstructor = constructor_arr.find(c => c.id == d.id);
    populateCurrentConstructorTable(selectedConstructor);
    d3.select(this).attr("r", d.radius * 1.2);
  }

  function handleMouseOutConstructor(d, i) {
    selectedConstructor = null;
    clearCurrentConstructorTable();
    // Use D3 to select element, change color back to normal
    d3.select(this).attr("r", d.radius);
  }

  function handleMouseClickOnConstructor(d, i) {
    selectedConstructor = constructor_arr.find(c => c.id == d.id);
    console.log("selected constructor", selectedConstructor);
    document.getElementById('page-1').classList.toggle('closed');
    loadDriversPage();

  }


  // Create Event Handlers for mouse
  function handleMouseOverText(d, i) {  // Add interactivity

    // Use D3 to select element, change color and size
    d3.select(this).attr("r", d.radius * 1.2);
  }

  function handleMouseOutText(d, i) {
    // Use D3 to select element, change color back to normal
    d3.select(this).attr("r", d.radius);
  }


  function populateCurrentConstructorTable(selectedConstructor) {
    document.getElementById("td-constructor-name").innerHTML = selectedConstructor.name;
    document.getElementById("td-constructor-nationality").innerHTML = selectedConstructor.nationality;
    document.getElementById("td-constructor-races").innerHTML = selectedConstructor.races;
    document.getElementById("td-constructor-wins").innerHTML = selectedConstructor.wins;
  }

  function clearCurrentConstructorTable() {
    document.getElementById("td-constructor-name").innerHTML = '';
    document.getElementById("td-constructor-nationality").innerHTML = '';
    document.getElementById("td-constructor-races").innerHTML = '';
    document.getElementById("td-constructor-wins").innerHTML = '';
  }


</script>
<script>

</script>

